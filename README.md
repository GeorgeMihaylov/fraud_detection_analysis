## Решение задачи выявления мошеннических транзакций

### 1. Обзор задачи и подход

Основной целью проекта было построение модели машинного обучения для эффективного выявления мошеннических финансовых транзакций. Задача классификации является сильно несбалансированной, где количество мошеннических операций (положительный класс) значительно меньше, чем легитимных. Наш подход включал в себя следующие ключевые этапы:

1.  **Загрузка и предварительный анализ данных**: Изучение структуры и содержания предоставленных файлов `transaction_fraud_data.parquet` и `historical_currency_exchange.parquet`.
2.  **Генерация признаков (Feature Engineering)**: Создание новых признаков и преобразование существующих для повышения информативности данных для модели.
3.  **Предварительная обработка данных (Preprocessing)**: Подготовка данных к обучению модели, включая кодирование категориальных признаков, масштабирование числовых и разделение на выборки.
4.  **Построение и обучение модели**: Выбор подходящей модели машинного обучения и её обучение на подготовленных данных.
5.  **Оценка модели**: Анализ производительности модели с использованием релевантных метрик.
6.  **Интерпретация модели**: Понимание, какие признаки оказали наибольшее влияние на предсказания.
7.  **Сохранение модели**: Сохранение обученной модели для дальнейшего использования.

### 2. Детальное описание этапов и принятые решения

#### 2.1. Загрузка и первичный анализ данных

* **Файлы**: `transaction_fraud_data.parquet` (основные транзакции) и `historical_currency_exchange.parquet` (курсы валют).
* **Решение**: Загрузка данных с помощью `pandas`. Первичный анализ показал наличие категориальных, числовых и булевых признаков, а также вложенной структуры `last_hour_activity` и необходимость конвертации валют.

#### 2.2. Генерация признаков (Feature Engineering)

* **Конвертация валют в USD (`amount_usd`)**:
    * **Проблема**: Суммы транзакций представлены в разных валютах, что делает их несопоставимыми напрямую.
    * **Решение**: Создан новый признак `amount_usd` путем умножения `amount` на соответствующий курс обмена валюты к USD на дату транзакции. Использовались данные из `historical_currency_exchange.parquet`. Для транзакций в USD обменный курс принимался равным 1.
* **Извлечение признаков из `last_hour_activity`**:
    * **Проблема**: `last_hour_activity` является вложенной структурой (`StructType`), которую нельзя напрямую использовать в большинстве моделей ML.
    * **Решение**: Вложенные поля `num_transactions`, `total_amount`, `unique_merchants`, `unique_countries`, `max_single_amount` были извлечены и преобразованы в отдельные плоские столбцы DataFrame. Это обогатило набор признаков важными агрегированными показателями активности клиента за последний час.
* **Определение целевой переменной и признаков**:
    * **Решение**: `is_fraud` был определен как целевая переменная (`y`). Остальные подходящие столбцы после генерации признаков были выбраны в качестве признаков (`X`).

#### 2.3. Предварительная обработка данных (Preprocessing)

* **Разделение данных**:
    * **Решение**: Данные были разделены на обучающую (60%), валидационную (20%) и тестовую (20%) выборки с использованием `train_test_split` из `sklearn.model_selection`.
    * **Ключевое решение**: Применена **стратификация по целевой переменной (`stratify=y`)** на каждом этапе разделения. Это критически важно для сильно несбалансированных классов, чтобы гарантировать одинаковое процентное соотношение мошеннических транзакций во всех выборках.
* **Обработка признаков (`ColumnTransformer`)**:
    * **Числовые признаки**: `StandardScaler` использовался для масштабирования числовых признаков (`amount_usd`, `num_transactions`, `total_amount`, `unique_merchants`, `unique_countries`, `max_single_amount`). Это помогает моделям, чувствительным к масштабу признаков.
    * **Категориальные признаки**: `OneHotEncoder` использовался для кодирования категориальных признаков (таких как `vendor_category`, `currency`, `card_type` и т.д.).
    * **Решение проблем с `MemoryError`**:
        * При первоначальной попытке `OneHotEncoder` столкнулись с `MemoryError` из-за высокой кардинальности признаков `city` и `country`. **Принято решение временно исключить** эти признаки из дальнейшего рассмотрения, поскольку их One-Hot Encoding привел бы к огромному количеству столбцов и превысил доступную память.
        * Дополнительная `MemoryError` возникла при преобразовании булевых признаков (`is_card_present`, `is_outside_home_country`, `is_high_risk_vendor`, `is_weekend`) к `int`. **Принято решение** извлечь эти признаки отдельно, преобразовать их к типу `np.int8` (наименьший целочисленный тип, достаточный для 0/1 значений) и затем **объединить** их с результатами `ColumnTransformer` (которые являются разреженной матрицей) с помощью `scipy.sparse.hstack`. Это позволило избежать внутренней обработки `pandas` или `ColumnTransformer`, которая вызывала переполнение памяти.

#### 2.4. Построение и обучение модели

* **Выбор модели**:
    * **Решение**: Выбран **LightGBMClassifier**.
    * **Обоснование**: LightGBM — это высокопроизводительный фреймворк градиентного бустинга, известный своей скоростью, эффективностью и способностью хорошо справляться с большими наборами данных и несбалансированными классами.
* **Настройка параметров для несбалансированных данных**:
    * **Решение**: Использован параметр `scale_pos_weight`, рассчитанный как отношение количества негативных к позитивным примерам в обучающей выборке. Это заставляет модель уделять больше внимания миноритарному классу (мошенничеству).
* **Предотвращение переобучения**:
    * **Решение**: Применена **ранняя остановка (early stopping)** с параметром `callbacks=[lgb.early_stopping(100, verbose=True)]`. Обучение останавливалось, если метрика `auc` на валидационной выборке не улучшалась в течение 100 итераций.

#### 2.5. Оценка модели

* **Метрики**:
    * **ROC AUC**: Измерена площадь под кривой рабочих характеристик приемника. Получены очень высокие значения (0.9974 на валидации и тесте), что указывает на отличную способность модели различать классы.
    * **Precision-Recall AUC (PR AUC)**: Измерена площадь под кривой Precision-Recall. Получены также очень высокие значения (0.9920 на валидации и 0.9921 на тесте). Эта метрика особенно важна для сильно несбалансированных классов, поскольку она фокусируется на производительности модели по отношению к положительному классу и менее чувствительна к большому количеству истинно отрицательных результатов.
    * **Classification Report**: Детальный отчет, включающий `Precision`, `Recall` и `F1-score` для каждого класса. Для класса "True" (мошенничество) получены отличные значения: `Precision ~0.91` (91% предсказанных мошеннических операций действительно были мошенническими) и `Recall ~0.97` (модель обнаружила 97% всех фактических мошеннических операций), что является выдающимся результатом для задачи выявления мошенничества.
* **Выводы**: Модель демонстрирует высокую точность и полноту, а схожесть метрик на валидационной и тестовой выборках подтверждает хорошую обобщающую способность и отсутствие переобучения.

#### 2.6. Интерпретация важности признаков

* **Метод**: Использован встроенный метод `feature_importances_` модели LightGBM.
* **Ключевые выводы**: Наиболее важными признаками оказались `amount_usd`, `max_single_amount`, `num_transactions`, `total_amount` (все из `last_hour_activity` или прямо из транзакции). Также высокую важность показали типы карт, валюты и признак `is_outside_home_country`. Это дает ценные бизнес-инсайты о том, какие факторы чаще всего связаны с мошенничеством.

#### 2.7. Сохранение модели

* **Решение**: Обученная модель `lgbm_model` была сохранена на диск с помощью библиотеки `joblib` в файл `lgbm_fraud_detection_model.joblib`. Это позволяет повторно использовать модель для предсказаний без необходимости ее переобучения.

### 3. Используемые инструменты и библиотеки

* **Python**: Основной язык разработки.
* **pandas**: Для работы с табличными данными (DataFrame).
* **numpy**: Для численных операций и работы с массивами.
* **scikit-learn**: Для разделения данных (`train_test_split`), масштабирования (`StandardScaler`), кодирования (`OneHotEncoder`), создания конвейера (`ColumnTransformer`) и оценки метрик (`classification_report`, `roc_auc_score`, `precision_recall_curve`, `auc`).
* **lightgbm**: Для построения основной модели машинного обучения (`LGBMClassifier`).
* **matplotlib** и **seaborn**: Для визуализации данных и важности признаков.
* **scipy.sparse**: Для эффективной работы с разреженными матрицами, которые создаются `OneHotEncoder`.
* **joblib**: Для сохранения и загрузки обученной модели.

---

# Общее описание `transaction_fraud_data.parquet`

Этот анонимизированный набор данных реальных финансовые транзакции, который предназначен для разработки и тестирования моделей выявления мошеннических операций.

Он охватывает различные сценарии — от розничной торговли и ресторанов до путешествий и здравоохранения — и включает как легитимные, так и мошеннические операции. В нём представлены важные признаки, влияющие на распознавание мошенничества: сумма, тип устройства, география, валюта, тип карты и метка `is_fraud`.

## Ключевые особенности

- **Разнообразие категорий**: Розница (онлайн и офлайн), рестораны (фастфуд и премиум), развлечения, здравоохранение, образование, топливо, путешествия и др.
- **География и валюта**: Транзакции охватывают разные страны, города и валюты, что позволяет моделировать глобальные риски.
- **Профили клиентов**: Для каждой транзакции предусмотрены данные о клиенте — возраст аккаунта, используемые устройства, типичные траты, уровень защиты от мошенничества.
- **Данные, готовые для ML**: Признаки включают скорость транзакций, риск вендора, присутствие карты, отпечатки устройств и другие факторы, помогающие обнаруживать подозрительные паттерны.

## Возможные применения

- Построение моделей выявления мошенничества.
- Анализ транзакционного поведения клиентов.
- Разработка и тестирование алгоритмов обнаружения аномалий.
- Изучение методов feature engineering, оценки моделей и оптимизации производительности в сфере финтеха и e-commerce.


# Содержание файла `transaction_fraud_data.parquet`

| Поле | Описание | Тип |
|------|----------|-----|
| `transaction_id` | Уникальный идентификатор транзакции | String | 
| `customer_id` | Уникальный идентификатор клиента | String | 
| `card_number` | Маскированный номер карты | Int64 |
| `timestamp` | Дата и время транзакции | Datetime(time_unit='us') |
| `vendor_category` | Общая категория вендора (например, Розница, Путешествия) | String |
| `vendor_type` | Тип вендора внутри категории (например, "онлайн") | String |
| `vendor` | Название вендора | String |
| `amount` | Сумма транзакции | Float64 |
| `currency` | Валюта (например, USD, EUR, JPY) | String |
| `country` | Страна, где проведена транзакция | String |
| `city` | Город, где проведена транзакция | String |
| `city_size` | Размер города (например, средний, крупный) | String |
| `card_type` | Тип карты (например, Basic Credit, Gold Credit) | String |
| `is_card_present` | Присутствовала ли карта физически при оплате (POS) | Boolean |
| `device` | Устройство, с которого проведена транзакция (например, Chrome, iOS App) | String |
| `channel` | Канал проведения транзакции (веб, мобильный, POS) | String |
| `device_fingerprint` | Уникальный отпечаток устройства | String |
| `ip_address` | IP-адрес транзакции | String | 
| `is_outside_home_country` | Признак того, что операция проведена вне страны клиента | Boolean |
| `is_high_risk_vendor` | Является ли категория вендора рискованной (например, Путешествия, Развлечения) | Boolean |
| `is_weekend` | Произошла ли операция в выходной день | Boolean |
| `last_hour_activity` | Показатели активности за последний час в виде вложенной структуры | Struct({'num_transactions': Int64, 'total_amount': Float64, 'unique_merchants': Int64, 'unique_countries': Int64, 'max_single_amount': Float64}) |
| `is_fraud` | Является ли транзакция мошеннической (`True` / `False`) | Boolean |

Составное поле `last_hour_activity`:

| Ключ | Описание | Тип |
|------|----------|-----|
| `num_transactions` | Количество транзакций | Int64 |
| `total_amount` | Общая сумма транзакций | Float64 |
| `unique_merchants` | Число уникальных продавцов | Int64 |
| `unique_countries` | Число уникальных стран | Int64 |
| `max_single_amount` | Максимальная сумма одной транзакции | Float64 |


# Содержание файла `historical_currency_exchange.parquet`

Вспомогательные данные для перевода операций в нужную валюту.

Обменный курс с `2024-09-30` по `2024-10-30` относительно `USD`.

| Поле | Описание | Тип |
|------|----------|-----|
| `date` | Дата обменного курса | Date | 
| `AUD` | Австралийский доллар | Float64 | 
| `BRL` | Бразильский реал | Float64 |
| `CAD` | Канадский доллар | Float64 |
| `EUR` | Евро | Float64 |
| `GBP` | Британский фунт стерлингов | Float64 |
| `JPY` | Японская иена | Float64 |
| `MXN` | Мексиканское песо | Float64 |
| `NGN` | Нигерийская найра | Float64 |
| `RUB` | Российский Рубль | Float64 |
| `SGD` | Сингапурский доллар | Float64 |
| `USD` | Доллар США | Int64 |
